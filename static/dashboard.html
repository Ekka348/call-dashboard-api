<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Real-Time Leads Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Все ваши стили остаются без изменений */
    :root {
      --primary: #4285f4;
      --success: #34a853;
      --warning: #fbbc05;
      --danger: #ea4335;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f7fa;
    }
    
    /* ... остальные стили ... */
  </style>
</head>
<body>
  <!-- HTML-структура остается без изменений -->
  <div id="app-container">
    <div class="container">
      <!-- Ваш существующий контент dashboard -->
    </div>
  </div>

  <script>
    const STAGES = {
      "На согласовании": { 
        id: "agreement", 
        color: "rgba(66, 133, 244, 0.8)",
        bgColor: "rgba(66, 133, 244, 0.2)",
        element: "agreement-content", 
        count: "agreement-count", 
        header: "agreement-header" 
      },
      "Перезвонить": { 
        id: "callback", 
        color: "rgba(251, 188, 5, 0.8)",
        bgColor: "rgba(251, 188, 5, 0.2)",
        element: "callback-content", 
        count: "callback-count", 
        header: "callback-header" 
      },
      "Приглашен к рекрутеру": { 
        id: "invited", 
        color: "rgba(52, 168, 83, 0.8)",
        bgColor: "rgba(52, 168, 83, 0.2)",
        element: "invited-content", 
        count: "invited-count", 
        header: "invited-header" 
      }
    };
    
    // Конфигурация
    let lastUpdateTime = 0;
    const POLLING_INTERVAL = 60000;
    let retryDelay = 1000;
    let isFirstLoad = true;
    let allOperators = [];
    let charts = {};
    let currentPeriod = 'hourly';
    
    // Инициализация приложения
    function initializeApp() {
      // Проверка необходимых DOM-элементов
      const requiredElements = [
        'trendChart', 'agreementChart', 'callbackChart', 'invitedChart',
        'agreement-content', 'callback-content', 'invited-content',
        'connection-status', 'status-text', 'last-update', 'operator-select'
      ];
      
      const missingElements = requiredElements.filter(id => !document.getElementById(id));
      if (missingElements.length > 0) {
        console.error("Missing required elements:", missingElements);
        return false;
      }

      initCharts();
      fetchData();
      setInterval(fetchData, POLLING_INTERVAL);
      setupEventListeners();
      
      return true;
    }
    
    // Инициализация графиков
    function initCharts() {
      try {
        charts.trend = new Chart(
          document.getElementById('trendChart'),
          {
            type: 'line',
            data: { datasets: [] },
            options: {
              responsive: true,
              plugins: { legend: { position: 'top' } }
            }
          }
        );
        
        Object.entries(STAGES).forEach(([stageName, stageConfig]) => {
          charts[stageConfig.id] = new Chart(
            document.getElementById(`${stageConfig.id}Chart`),
            {
              type: 'bar',
              data: { labels: [], datasets: [] },
              options: {
                responsive: true,
                plugins: { legend: { display: false } }
              }
            }
          );
        });
      } catch (e) {
        console.error("Chart initialization error:", e);
      }
    }
    
    // Загрузка данных
    async function fetchData() {
      try {
        console.log("[%s] Fetching data...", new Date().toISOString());
        
        const [dashboardResponse, operatorsResponse] = await Promise.all([
          fetch('/api/leads/by-stage?t=' + Date.now()).catch(handleFetchError),
          fetch('/api/leads/operators?t=' + Date.now()).catch(handleFetchError)
        ]);

        // Проверка ответов
        if (!dashboardResponse?.ok) {
          throw new Error(`Dashboard request failed: ${dashboardResponse?.status}`);
        }
        if (!operatorsResponse?.ok) {
          throw new Error(`Operators request failed: ${operatorsResponse?.status}`);
        }

        const [data, operatorsData] = await Promise.all([
          dashboardResponse.json().catch(() => null),
          operatorsResponse.json().catch(() => null)
        ]);

        // Валидация данных
        if (!data || typeof data !== 'object') {
          throw new Error("Invalid dashboard data format");
        }
        if (!operatorsData || typeof operatorsData !== 'object') {
          throw new Error("Invalid operators data format");
        }

        // Нормализация данных
        const normalizedData = {
          status: data.status || "success",
          current: data.current || {},
          history: data.history || {
            hourly: { labels: [], data: {} },
            daily: { labels: [], data: {} }
          },
          changes: data.changes || [],
          timestamp: data.timestamp || new Date().toLocaleString()
        };

        updateDashboard(normalizedData);
        updateOperatorSelect(operatorsData.operators || []);
        
        lastUpdateTime = Date.now();
        updateConnectionStatus(true);
        document.getElementById('last-update').textContent = normalizedData.timestamp;
        
        return true;
      } catch (error) {
        console.error("Data fetch error:", error);
        handleDataError(error);
        return false;
      }
    }
    
    // Обновление дашборда
    function updateDashboard(data) {
      if (!data || typeof data !== 'object') {
        console.error("Invalid data in updateDashboard:", data);
        return;
      }

      try {
        updateCharts(data);
        
        Object.entries(data.current).forEach(([stageName, stageData]) => {
          updateStage(stageName, stageData);
        });
        
        if (data.changes?.length > 0) {
          showChangesNotification(data.changes);
        }
      } catch (e) {
        console.error("Dashboard update error:", e);
      }
    }
    
    // Обновление графиков
    function updateCharts(data) {
      if (!data?.history || !data?.current) {
        console.error("Missing required data for charts:", data);
        return;
      }

      // Обновление основного графика трендов
      try {
        const historyData = data.history[currentPeriod] || { labels: [], data: {} };
        
        charts.trend.data = {
          labels: historyData.labels || [],
          datasets: Object.entries(historyData.data || {})
            .filter(([stage]) => STAGES[stage])
            .map(([stage, values]) => ({
              label: stage,
              data: values,
              borderColor: STAGES[stage].color,
              backgroundColor: STAGES[stage].bgColor,
              borderWidth: 2,
              tension: 0.1,
              fill: true
            }))
        };
        charts.trend.update();
      } catch (e) {
        console.error("Trend chart update error:", e);
      }

      // Обновление графиков по этапам
      Object.entries(data.current).forEach(([stageName, stageData]) => {
        try {
          const stageConfig = STAGES[stageName];
          if (!stageConfig || !charts[stageConfig.id]) return;

          charts[stageConfig.id].data = {
            labels: stageData.details?.map(d => d.operator) || [],
            datasets: [{
              label: 'Лиды',
              data: stageData.details?.map(d => d.count) || [],
              backgroundColor: stageConfig.color,
              borderColor: stageConfig.color,
              borderWidth: 1
            }]
          };
          charts[stageConfig.id].update();
        } catch (e) {
          console.error(`Chart update error for ${stageName}:`, e);
        }
      });
    }
    
    // Обновление таблицы этапа
    function updateStage(stageName, stageData) {
      const stageConfig = STAGES[stageName];
      if (!stageConfig) {
        console.warn(`Unknown stage: ${stageName}`);
        return;
      }

      const container = document.getElementById(stageConfig.element);
      const countElement = document.getElementById(stageConfig.count);
      
      if (!container || !countElement) {
        console.error(`Elements not found for stage: ${stageName}`);
        return;
      }

      // Обновление общего количества
      const totalCount = stageData.details?.reduce((sum, item) => sum + (item.count || 0), 0) || 0;
      countElement.textContent = totalCount;

      // Обновление содержимого таблицы
      if (!stageData.details || stageData.details.length === 0) {
        container.innerHTML = '<div class="empty">Нет данных</div>';
        return;
      }

      let html = `
        <table>
          <thead>
            <tr>
              <th>Оператор</th>
              <th class="count-cell">Кол-во</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      stageData.details.forEach(item => {
        html += `
          <tr class="operator-row" data-operator="${item.operator || ''}">
            <td>${item.operator || 'Неизвестный'}</td>
            <td class="count-cell">
              <span class="count-value">${item.count || 0}</span>
            </td>
          </tr>
        `;
      });
      
      html += `</tbody></table>`;
      container.innerHTML = html;
    }
    
    // Обработчики событий
    function setupEventListeners() {
      // Переключение периода графиков
      document.querySelectorAll('.chart-actions button').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.chart-actions button').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          currentPeriod = this.dataset.period;
          fetchData();
        });
      });
      
      // Фильтр операторов
      document.getElementById('operator-select').addEventListener('change', applyOperatorFilter);
    }
    
    // Фильтрация по операторам
    function applyOperatorFilter() {
      const selectedOperator = document.getElementById('operator-select').value;
      
      document.querySelectorAll('.operator-row').forEach(row => {
        const rowOperator = row.dataset.operator;
        const shouldShow = !selectedOperator || rowOperator === selectedOperator;
        
        row.classList.toggle('hidden-row', !shouldShow);
        row.classList.toggle('highlight-operator', selectedOperator && rowOperator === selectedOperator);
      });
      
      // Показать сообщение, если нет видимых строк
      document.querySelectorAll('.card-body').forEach(card => {
        const table = card.querySelector('table');
        if (!table) return;
        
        const visibleRows = table.querySelectorAll('tbody tr:not(.hidden-row)').length;
        const emptyMessage = card.querySelector('.empty-message') || createEmptyMessage(card);
        
        emptyMessage.classList.toggle('show-empty-message', visibleRows === 0);
      });
    }
    
    // Обновление списка операторов
    function updateOperatorSelect(operators) {
      const select = document.getElementById('operator-select');
      if (!select) return;
      
      // Проверяем, изменились ли операторы
      if (JSON.stringify(operators) === JSON.stringify(allOperators)) return;
      
      allOperators = operators || [];
      select.innerHTML = '<option value="">Все операторы</option>';
      
      allOperators.forEach(operator => {
        const option = document.createElement('option');
        option.value = operator;
        option.textContent = operator;
        select.appendChild(option);
      });
    }
    
    // Управление статусом соединения
    function updateConnectionStatus(connected) {
      const statusElement = document.getElementById('connection-status');
      const statusText = document.getElementById('status-text');
      
      if (statusElement) {
        statusElement.className = 'indicator ' + (connected ? 'connected' : 'disconnected');
      }
      if (statusText) {
        statusText.textContent = connected ? 'Connected' : 'Disconnected';
      }
    }
    
    // Показать уведомление об изменениях
    function showChangesNotification(changes) {
      if (!changes?.length) return;
      
      const notification = document.createElement('div');
      notification.className = 'changes-notification';
      notification.innerHTML = `
        <h4>Изменения в лидах</h4>
        <ul>
          ${changes.map(change => `
            <li>
              ${change.operator || 'Неизвестный'}: ${change.stage || 'Неизвестный этап'} 
              (${change.diff > 0 ? '+' : ''}${change.diff || 0})
            </li>
          `).join('')}
        </ul>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 500);
      }, 5000);
    }
    
    // Создать сообщение об отсутствии данных
    function createEmptyMessage(container) {
      const message = document.createElement('div');
      message.className = 'empty-message';
      message.textContent = 'Нет данных для выбранного оператора';
      container.appendChild(message);
      return message;
    }
    
    // Обработка ошибок запросов
    function handleFetchError(error) {
      console.error("Fetch error:", error);
      throw error;
    }
    
    // Обработка ошибок данных
    function handleDataError(error) {
      console.error("Data processing error:", error);
      updateConnectionStatus(false);
      
      const errorMessage = error.message || "Unknown error";
      const lastUpdateElement = document.getElementById('last-update');
      const statusTextElement = document.getElementById('status-text');
      
      if (lastUpdateElement) {
        lastUpdateElement.textContent = `Ошибка: ${errorMessage}`;
      }
      if (statusTextElement) {
        statusTextElement.textContent = 'Ошибка соединения';
      }

      // Показать ошибки во всех секциях
      Object.values(STAGES).forEach(stage => {
        const container = document.getElementById(stage.element);
        if (!container) return;
        
        const errorDiv = container.querySelector('.error-message') || document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = `Ошибка загрузки данных: ${errorMessage}`;
        
        if (!container.contains(errorDiv)) {
          container.innerHTML = '';
          container.appendChild(errorDiv);
        }
      });
    }
    
    // Запуск приложения после загрузки DOM
    document.addEventListener('DOMContentLoaded', initializeApp);
  </script>
</body>
</html>
